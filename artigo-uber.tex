\documentclass[12pt]{article}
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{hyperref}
\usepackage[alf]{abntex2cite}
\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc} 
     
\sloppy

\title{Estudo de Caso da infraestrutura de banco de dados da Uber}

\author{Athos Castro Moreno, Lais Brazil Peixoto Macedo}

\address{Departamento de Computação - Universidade Tecnológica Federal do Paraná
  (UTFPR)\\
  Avenida Alberto Carazzai, 1640 -- 86300000 -- Cornélio Procópio -- PR -- Brasil
  \email{athos@alunos.utfpr.edu.br, lais.macedo@outlook.com}
}

\begin{document} 

\maketitle
     
\begin{resumo} 
  
\end{resumo}

\section{Introdução}

A internet se tornou, atualmente, um fator primordial de uma sociedade e um fator critico no crescimento de uma nação. É possível afirmar que a sociedade atual vive na economia da informação e que
a produtividade e competividade de uma empresa depende da capacidade de criar, processar e aplicar informação baseada em conhecimento, dependendo do uso intensivo da tecnologia.
É estimado que pelo menos dois terços das empresas existentes no mundo tem algum tipo de presença na internet. 
Também é estimado que o \textit{ecommerce} movimenta oito trilhões de dólares anualmente e que a internet contribui mais que a agricultura, energia e outros setores tradicionais no PIB de uma nação \cite{Boban2017} \cite{Rausas2011}.

Porém, para uma empresa utilizar a internet em todo o seu potencial, ela depende de \textit{softwares} criados com qualidade e que sejam confiáveis. Para isso, é necessário que sejam aplicadas técnicas durante sua criação, conhecidas no geral
pelo nome de arquitetura de software.

O conceito de arquitetura de software tem emergido como uma pratica importante no desenvolvimento e na engenharia de software. 
De forma geral, arquitetura é uma divisão prudente do todo em partes, relacionando-as especificamente entre si e 
estabelecendo restrições nas atividades futuras \cite{Clements2010}. 

Uma aplicação pode ser classificada como monolítica, na qual as funcionalidades são agrupadas dentro de um único e grande sistema,
minimizando a duplicidade de código e exigindo um único \textit{deploy}. A arquitetura monolítica tem como desvantagem a falta de 
flexibilidade, escalabilidade limitada e principalmente a falhas. Se um módulo estiver com erro todo o sistema fica indisponível, 
causando uma interdependência grande entre os módulos do sistema. Uma alternativa em grande uso é a arquitetura 
de microserviços, onde os módulos são dependentes e não causam grande dano quanto um está fora do ar como no monolítico \cite{Clements2010}.

\section{Problema} 

Uma empresa grande possui diversas informações armazenadas, que são constantemente requisitadas por diversos serviços, sejam aparelhos de clientes finais
ou sistemas de \textit{middleware}. O sistema de banco de dados selecionado não pode demorar para entregar as informações requisitadas, muito menos perde-las.
Centralizar todos os dados da empresa em um único servidor de banco de dados pode, em alguns casos, não ser a melhor saída, devido questões de performance e segurança, 
sendo necessário descobrir novas formas de implementar uma estrutura de banco de dados confiável.

\section{Objetivo}

Neste trabalho será relatado como a Uber armazena suas informações, através do conhecido SGBD (Sistema de Gerenciamento de Banco de Dados) MySQL, da Oracle em uma arquitetura de 
microserviços, os motivos desta abordagem, suas vantagens e como é utilizada. 

\section{Estudo de Caso} 

\subsection{Empresa estudada}

A empresa norte-americana UberCab, fundada em 2009 por Garrett Camp e Travis Kalanick com a proposta inicial de ser um serviço semelhante a um táxi com carros de luxo 
pretos tendo as requisições feitas por um dispositivo eletrônico. Em maio de 2010 foi lançada a versão beta e somente em 2011 o serviço foi lançado oficialmente na 
cidade de São Francisco com preços mais caros que um táxi normal. 
Em 2011 a companhia mudou seu nome para Uber e em julho de 2012 foi introduzido o serviço UberX, permitindo que pessoas dirigissem com seus próprios carros. 
Em 2013 o serviço já estava em 35 cidades. Hoje a Uber possui serviços de transportes, entregas de alimentos e pacotes, com colaboradores utilizando desde bicicletas 
até caminhões, presente em 633 cidades do mundo \cite{uber2017}.

\subsection{Técnicas de arquitetura de software utilizadas}

\subsubsection{Microserviços}

Um microserviço é um serviço que tem uma responsabilidade limitada, reduzida, autônoma e modelado em base de domínios específicos de negócio. Desta forma, um conjunto de microserviços irão resultar
em uma aplicação. Da perspectiva do desenvolvimento, cada serviço deve ser tratado como uma aplicação diferente, com seus próprios repositórios. Microserviços podem ser implementados
em qualquer linguagem ou \textit{framework} que o desenvolvedor desejar \cite{Jaramillo2016}.

Como vantagens em utilizar microserviços, é possível listar o aumento de escalabilidade, menos barreiras para introduzir novas tecnologias dentro de um projeto,
inicio mais rápido das aplicações, desde que seja implementado da forma correta, aumento de reuso e facilidade de substituição dos componentes, quando necessário
\cite{Gouigoux2017} \cite{Khazaei2016} \cite{Yousif2016}.

Como desafios da implementação de microserviços pode ser listada a dificuldade de encontrar a granularidade correta dos serviços -- quanto é muito, quanto é pouco? -- de um sistema,
necessidade de automação -- a implementação de uma aplicação monolítica demora horas, a implementação de uma aplicação de microserviços pode demorar dias sem automação -- 
durante a implementação e garantir a independência -- se um serviço cair, os outros devem funcionar normalmente ou, no máximo, com funcionalidades reduzidas -- dos 
serviços entre si. Uma das vantagens de utilizar microserviços, a escalabilidade, pode também ser um desafio se não implementada corretamente no inicio do desenvolvimento
do projeto. É também necessário traçar estratégias para a elaboração de testes, como os serviços são fragmentados e cada um é um sistema independente, todos precisam ter seus próprios testes
\cite{Jaramillo2016} \cite{Gouigoux2017}.

Existe uma forte ligação entre arquiteturas baseadas em serviços e o conceito de \textit{containers}, que neste artigo utilizaremos o Docker \cite{Gouigoux2017}. 

\subsection{Tecnologias utilizadas}

\subsubsection{MySQL}

MySQL é um SGBD escrito nas linguagens C e C++ com suporte a banco de dados de todos os tamanhos.
É mantido atualmente pela Oracle e é um dos sistemas SGBD mais utilizados mundialmente \cite{mysql2017}.
Seu código fonte é disponível através da licença \textit{GNU General Public License}, porém é necessário comprar uma licença para uso comercial.
É o banco de dados utilizado na tradicional \textit{stack} de aplicações LAMP (Linux, Apache, MySQL e PHP/Perl/Python). Dentro das aplicações que utilizam o MySQL
estão Drupal, WordPress, phpBB, dentre outras. É utilizado em \textit{websites} e empresas reconhecidas, 
incluindo Google, Facebook, Twitter, Yahoo!, entre outros \cite{mysql2017-2}.

\subsubsection{Docker}

Docker é uma plataforma de microserviços para desenvolvedores e operadores de infraestrutura. É utilizado para substituir o uso de maquinas virtuais em ambientes 
de desenvolvimento com o conceito de \textit{containers}, que são versões mais enxutas de sistemas operacionais, que funcionam isoladamente do sistema operacional 
hospedeiro e podem ser customizados e compartilhados através da plataforma Docker \cite{docker2017}.

Utiliza uma arquitetura cliente-servidor, sendo possível através de comandos em um \textit{shell} -- cmd.exe ou PowerShell 
no Windows, Bash e outros em distribuições GNU/Linux e Mac OS X -- no cliente para interagir com o hospedeiro Docker através
do \textit{daemon}. O \textit{daemon} é responsável pela construção, execução e distribuição dos \textit{containers} \cite{Jaramillo2016}.
Um \textit{daemon} é um programa que funciona em \textit{background} que efetua ações quando recebe comandos de terceiros \cite{christensson2006}.

Os conceitos principais para entender e utilizar o Docker são \cite{Jaramillo2016}:

\begin{itemize}
  \item \textbf{\textit{Container:}} Um \textit{container} do Docker é um ambiente isolado, incluindo um sistema operacional compartilhado, \textit{middleware} e quaisquer
  serviços e arquivos necessários para funcionar uma aplicação dentro de um container.
  \item \textbf{Imagem:} É um modelo somente escrita, no qual os \textit{containers} são baseados. Uma imagem tem como base outra imagem de um sistema operacional, sendo colocado
  componentes adicionais para posterior distribuição. Exemplos de imagens são a do PostgreSQL (\url{https://hub.docker.com/_/postgres/}), NodeJS (\url{https://hub.docker.com/_/node/})
  e MySQL (\url{https://hub.docker.com/_/mysql/}). Todas essas imagens tem como base algum sistema operacional -- geralmente o Debian GNU/Linux -- e podem ser baixadas, modificadas
  e redistribuídas por qualquer usuário do Docker.
  \item \textbf{Dockerfile:} É um arquivo texto que contem instruções a serem executadas em cima de uma imagem disponível no Docker Hub, a nuvem do Docker. Quando uma requisição de \textit{build}
  é executada com uma Dockerfile, o \textit{daemon} lê as instruções que estão no arquivo -- geralmente são comandos para serem executados no \textit{shell} do sistema operacional do \textit{container} -- e
  retornando o \textit{container} criado.
  \item \textbf{Docker Registry:} Imagens do Docker são salvas em repositórios e compartilhadas. O Docker possui uma nuvem publica e gratuita para ser utilizada chamada Docker Hub.
  Também é possível criar nuvens próprias para uso individual ou dentro de uma organização.
\end{itemize}

\section{Detalhes da Implementação}

Em 2016, a Uber anunciou através de um artigo em seu \textit{blog} de engenharia a troca do PostgreSQL para o MySQL, alegando restrições técnicas no projeto do PostgreSQL.
O anuncio também continha uma informação importante: o Uber utilizava uma arquitetura monolítica com o PostgreSQL e com a migração pro MySQL, haveria a mudança para uma arquitetura
de microserviços, alegando que o crescimento da Uber não era condizente com uma estrutura monolítica \cite{uber2016}.
Na sua criação, o Uber foi escrito em Python, utilizando como ORM (\textit{Object-Relational Mapping}) o SQLAcademy, com o PostgreSQL armazenando todos os dados em uma instancia única \cite{uber2015}.

Um ORM é um \textit{framework} que permite que um desenvolvedor manipule um banco de dados utilizando o paradigma orientado a objetos. Utilizar um ORM abstrai a implementação de trabalhar diretamente
com o banco de dados e fornece um mecanismo padrão para trabalhar com múltiplos SGBDs \cite{Juneau2013}.

Entre os motivos alegados para deixar de utilizar o PostgreSQL, estavam \cite{uber2016}:

\begin{itemize}
  \item Arquitetura ineficiente para escrita;
  \item Arquitetura ineficiente para replicação de dados;
  \item Problemas com corrupção de tabelas;
  \item Dificuldade para atualizar o PostgreSQL.
\end{itemize}

\subsection{Projeto \textit{Mezzanine}}

Atualmente, a Uber utiliza MySQL em um sistema \textit{Schemaless}, escrito em Python, bancos legados do PostgreSQL 9.2 e em alguns casos específicos,
bancos de dados NoSQL. Tanto os bancos de dados do MySQL e o sistema da Uber em si são desenvolvidos e implementados atualmente com o 
conceito de microserviços.

Como justificativa para a criação de uma solução própria, a Uber lista \cite{uber2016-2}:

\begin{itemize}
  \item Linearidade para adicionar capacidade através do crescimento do numero de servidores;
  \item Disponibilidade para escrita de dados através de um \textit{buffer} escalável;
  \item Notificação de dependências entre componentes avulsos, que antes eram acoplados;
  \item \textit{Index} secundários, para suportar o PostgreSQL;
  \item Confiança operacional no sistema, já que envolvia dados críticos e era necessário saber como o sistema funciona em casos de falha critica;
\end{itemize}

Os engenheiros da Uber, após analisar soluções existentes no mercado na época decidiram que pelos critérios
citados acima, era mais viável construir uma solução própria para armazenar e gerenciar seus dados de forma escalável. A criação e migração para o sistema \textit{Schemaless}
foi feita através de um projeto chamado \textit{Mezzanine}, que teve fim em setembro de 2014 sem nenhum \textit{downtime} no serviço da Uber \cite{uber2015}. 

O projeto \textit{Mezzanine} teve como foco, através da criação e implementação do \textit{Schemaless}, a mudança de como as viagens feitas no aplicativo da Uber são armazenadas. 
Desta forma, o \textit{Schemaless} teve como suas características principais \cite{uber2015}:

\begin{itemize}
  \item \textit{Sharding} (capacidade de armazenar dados em vários locais diferentes);
  \item Escrita \textit{append-only}, ou seja, os dados são apenas adicionados e nunca atualizados;
  \item \textit{Indexes} secundários em múltiplos locais (através do \textit{sharding});
  \item \textit{Buffered writes}: Se o local que um dado precisa ser gravado está lento, este dado é gravado em outro servidor disponível até a disponibilidade do primeiro acontecer.
\end{itemize}

A execução do projeto \textit{Mezzanine} não foi sem problemas. O maior deles foi a migração de IDs únicos das viagens para o uso de UUIDs (Universally Unique Identifier).
Um UUID é um identificador de 128 bits gerado por um algoritmo de forma a ser um identificador único, sendo improvável a criação de outro identificador igual em um momento futuro.
É escrito em uma sequencia de dígitos hexadecimais em grupos separados por hifens, de modo a formar 32 dígitos representando 128 bits.
Um exemplo de UUID é 12135aab-46da-4fd9-beb6-599adc00b041. O UUID é definido pelo padrão RFC 4122 \cite{postgresql2017}. O código original dependia de um auto incrementador do PostgreSQL,
porém, foi definido que usar um inteiro que se auto incrementa não era condizente com o crescimento do aplicativo, sendo a migração para o UUID necessária. Então, era necessário trocar todos os inteiros por UUIDs.
Outro problema foi que todas as \textit{queries} dentro do programa estavam no formato do ORM SQLAcademy. Era necessário reescrever todas para a API de queries do \textit{Schemaless}.
E durante o processo era necessário fazer a validação dos dados migrados para garantir sua integridade \cite{uber2015}.

\subsection{\textit{Dockerização} do MySQL}

O sistema de armazenamento \textit{Schemaless} funciona com diversos \textit{clusters} com o MySQL. É estimado que dentro da Uber existam mais de 
1,000 \textit{clusters} com mais de 4000 servidores de banco de dados. Para gerenciar isso, a equipe do Uber utilizou, no inicio, o \textit{software} Puppet, 
que é uma ferramenta de automação para configurações.
Junto com o Puppet, era utilizado alguns \textit{scripts} e algumas operações manuais, que não eram escaláveis com o crescimento da empresa.
A solução para este problema foi a criação de um design de sistema que foi dado o nome de Schemadock, constituindo em utilizar diversos containers do MySQL
no Docker \cite{uber2016-3}.

A imagem do Docker utilizada pela Uber, quando criada, baixa o que for necessário e inicia o MySQL.
Entre o processo de download e de inicio do MySQL, é verificado se no volume montado existe algum dado. Se não,
caso seja uma instancia mestre, é iniciado um \textit{script} que coloca alguns usuários e tabelas padrões. Caso seja uma instancia
escrava, inicia a sincronização de um \textit{backup} ou de outro \textit{node} no \textit{cluster}. Caso o processo de copia de dados falhe
em algum momento, o \textit{container} desliga. O papel do \textit{container} é definido através de variáveis de ambiente.
Os parâmetros de configuração do MySQL são inseridos dentro das imagens do Docker. Desta maneira, não é necessário (e não é feito)
reiniciar um \textit{container} caso ele pare por qualquer motivo. Quando isto acontece, o responsável na Uber simplesmente cria outro \textit{container}
com a ultima imagem utilizada. O diretório de dados do MySQL é montado do sistema de arquivos do \textit{host} \cite{uber2016-3}.

As vantagens desta abordagem são \cite{uber2016-3}:

\begin{itemize}
  \item Mudanças de configuração são mais fáceis de controlar, já que é necessário monitorar apenas as imagens;
  \item A atualização do MySQL se resume em criar um \textit{container} novo e desligar os existentes;
  \item Caso algo no \textit{container} atual não funcione corretamente, o atual é destruído e outro é criado do zero.
\end{itemize}

\subsection{Resultados}

\section{Análise crítica sobre o estudo de caso}

Os artigos da Uber apresentados neste artigo, assim como outros no blog de Engenharia da Uber (\url{https://eng.uber.com}), fornecem uma visão única de como funciona
internamente um aplicativo de sucesso mundial, incluindo como seus dados são gerenciados nos mínimos detalhes. Porém, é fácil de notar que
a Uber exige de seus engenheiros um alto grau de conhecimento das ferramentas e \textit{frameworks} selecionados para uso, sendo que em alguns casos,
a maioria deste artigo, a Uber preferiu criar soluções próprias em cima de soluções e conceitos já existentes. Também é notável o uso extenso e profundo do Docker dentro
da empresa, provando que é uma arquitetura relativamente madura e relevante na indústria. 

Tal grau de maturidade não é atingido facilmente, e muitas empresas de tecnologia, não importando o quão sensível são os dados que gerenciam e muitas vezes
não importando a quantidade de certificações e prêmios da indústria que possuem, não conseguem atingir tal nível de domínio de todas as partes da aplicação. 
É importante que empresas que possuem tal nível mostrem seus resultados, sejam para auxiliar a comunidade a criar aplicações robustas, confiáveis e que entregam 
valor para o usuário e para mostrar que uma \textit{start-up}, apesar de talvez ser simples no inicio de sua implementação, pode 
se tornar complicada facilmente e em pouco tempo. 

Enquanto muitas empresas tratam suas especificações internas como uma caixa preta, um numero grande de empresas renomadas -- tais como Uber, provado neste artigo, 
Facebook, Google, Microsoft, entre muitas outras -- estão criando diversos \textit{frameworks} para possibilitar que a comunidade crie aplicações cada vez melhores, assim como documentando seus procedimentos internos
para que a comunidade conheça e aprenda junto cada vez mais. Isso, ao invés de enfraquecer as empresas, seus aplicativos e seus objetivos empresariais, apenas vem fortalecendo. 

As técnicas e aplicações aplicadas e demonstradas pela Uber mostram que lidar com dados que são atualizados e requisitados a todo momento por usuários em todo o mundo, não é simples.
Porém, é possível questionar se técnicas como a \textit{Schemaless}, que utiliza o MySQL para retornar objetos NoSQL em JSON não são excessivamente complicadas, possibilitando soluções mais simples de serem consideradas.
Também é questionável a afirmação de que é mais fácil criar uma solução nova do que utilizar uma solução existente por ser mais difícil de entender uma solução já criada e testada em toda sua plenitude.

\section{Lições aprendidas}

Com o crescimento das empresas e integração de novos dados para a administração, a gestão do banco de dados tem sido um dos 
pontos mais importantes quando se trata de expansão. O ponto chave com relação aos dados armazenados é a integridade dos mesmos 
sendo inaceitável a perda de informações dentro de uma empresa, seja ela de grande ou pequeno porte. 
As requisições precisam ser executas com precisão e as respostas exibidas o mais rápido possível. 

Grandes soluções para tratamento dos dados existem e as grandes empresas tem a liberdade para utilizar \textit{frameworks} 
existentes ou até mesmo criar algo que as atenda da melhor maneira, gerando e disponibilizando cada vez mais soluções na área de 
tecnologia e desenvolvimento.

\section{Conclusão}

\bibliography{bibliografia}

\end{document}
